# Slack notification workflow for Mimir
# - Triggered via workflow_call from Release/CI (and manual dispatch) to post status updates
# - Routes main branch runs to the releases-dev channel via SLACK_CHANNEL_DEV secret
# - Determines release status via tag detection with pyproject.toml fallback for version display
name: Slack Message Dispatcher

on:
  workflow_call:
    inputs:
      branch:
        description: Target git branch (e.g., main)
        required: false
        type: string
      status:
        description: Conclusion status from the triggering workflow run
        required: false
        type: string
      run-url:
        description: URL to the triggering workflow run
        required: false
        type: string
      head_sha:
        description: Commit SHA associated with the workflow run
        required: false
        type: string
      actor:
        description: GitHub username that initiated the workflow run
        required: false
        type: string
      repo:
        description: Full repository name (owner/repo)
        required: false
        type: string
    secrets:
      SLACK_BOT_TOKEN:
        required: false
      SLACK_CHANNEL_DEV:
        required: false
  push:
    paths:
      - .github/workflows/slack-message.yml

jobs:
  post:
    if: github.event_name != 'push'
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:
      - name: Validate required secrets
        id: validate
        run: |
          missing=0
          if [ -z "${{ secrets.SLACK_BOT_TOKEN }}" ]; then
            echo "::warning::Missing SLACK_BOT_TOKEN secret. Slack notification will be skipped."
            missing=1
          fi
          if [ -z "${{ secrets.SLACK_CHANNEL_DEV }}" ]; then
            echo "::warning::SLACK_CHANNEL_DEV is not set. Notifications will be skipped."
            missing=1
          fi
          if [ $missing -eq 1 ]; then
            echo "skip=true" >> "$GITHUB_OUTPUT"
          fi

      - name: Determine environment metadata
        id: env-data
        if: steps.validate.outputs.skip != 'true'
        env:
          BRANCH: ${{ inputs.branch }}
          DEV_CHANNEL: ${{ secrets.SLACK_CHANNEL_DEV }}
          REPO: ${{ inputs.repo }}
        run: |
          # Show repo name in Slack headers (e.g., "Mimir (Main)")
          repo_display=${REPO##*/}
          if [ -z "$repo_display" ]; then
            repo_display="Main"
          else
            repo_display=${repo_display^}
          fi
          # For mimir, all main branch pushes go to releases-dev
          if [ "$BRANCH" = "main" ]; then
            channel="$DEV_CHANNEL"
            environment="$repo_display (Main)"
          else
            channel=""
            environment="$repo_display ($BRANCH)"
          fi

          trimmed=$(echo "$channel" | tr -d '[:space:]')
          if [ -z "$trimmed" ]; then
            echo "::warning::No Slack channel configured for branch '$BRANCH'. Skipping notification."
            echo "skip=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "channel=$channel" >> "$GITHUB_OUTPUT"
          echo "environment=$environment" >> "$GITHUB_OUTPUT"

      - name: Checkout commit
        if: steps.validate.outputs.skip != 'true' && steps.env-data.outputs.skip != 'true'
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ inputs.head_sha }}

      - name: Capture commit metadata
        id: commit
        if: steps.validate.outputs.skip != 'true' && steps.env-data.outputs.skip != 'true'
        env:
          HEAD_SHA: ${{ inputs.head_sha }}
        run: |
          subject=$(git log -1 --pretty=%s "$HEAD_SHA" 2>/dev/null || echo "")
          short_sha=$(git rev-parse --short "$HEAD_SHA" 2>/dev/null || echo "")
          echo "subject<<EOF" >> "$GITHUB_OUTPUT"
          echo "$subject" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "short=$short_sha" >> "$GITHUB_OUTPUT"

      - name: Detect version changes
        id: version
        if: steps.validate.outputs.skip != 'true' && steps.env-data.outputs.skip != 'true'
        env:
          HEAD_SHA: ${{ inputs.head_sha }}
        run: |
          version=""
          is_release=false
          has_version=false

          if git rev-parse "$HEAD_SHA" >/dev/null 2>&1; then
            tag=$(git describe --exact-match --tags "$HEAD_SHA" 2>/dev/null || true)
            if [ -n "$tag" ]; then
              version="$tag"
              is_release=true
              has_version=true
            fi
          fi

          if [ "$has_version" = false ] && [ -f "pyproject.toml" ]; then
            py_version=$(grep 'version = ' pyproject.toml | head -n1 | cut -d'"' -f2)
            if [ -n "$py_version" ]; then
              case "$py_version" in
                v*)
                  version="$py_version"
                  ;;
                *)
                  version="v$py_version"
                  ;;
              esac
              has_version=true
            fi
          fi

          echo "is_release=$is_release" >> "$GITHUB_OUTPUT"
          echo "has_version=$has_version" >> "$GITHUB_OUTPUT"
          echo "version=$version" >> "$GITHUB_OUTPUT"

      - name: Build Slack payload
        id: payload
        if: steps.validate.outputs.skip != 'true' && steps.env-data.outputs.skip != 'true'
        env:
          STATUS: ${{ inputs.status }}
          CHANNEL: ${{ steps.env-data.outputs.channel }}
          ENVIRONMENT: ${{ steps.env-data.outputs.environment }}
          IS_RELEASE: ${{ steps.version.outputs.is_release }}
          HAS_VERSION: ${{ steps.version.outputs.has_version }}
          VERSION: ${{ steps.version.outputs.version }}
          SUBJECT: ${{ steps.commit.outputs.subject }}
          SHORT_SHA: ${{ steps.commit.outputs.short }}
          HEAD_SHA: ${{ inputs.head_sha }}
          REPO: ${{ inputs.repo }}
          ACTOR: ${{ inputs.actor }}
          RUN_URL: ${{ inputs['run-url'] }}
        run: |
          python - <<'PY'
import json
import os

def slack_escape(value: str) -> str:
    return value.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')

status = os.environ.get('STATUS', 'unknown').lower()
status_label = status.upper() if status else 'UNKNOWN'
emoji = ':large_green_circle:' if status == 'success' else ':red_circle:'
environment = os.environ.get('ENVIRONMENT', 'Main')
is_release = os.environ.get('IS_RELEASE', 'false').lower() == 'true'
has_version = os.environ.get('HAS_VERSION', 'false').lower() == 'true'
version = os.environ.get('VERSION', '').strip()

subject = slack_escape(os.environ.get('SUBJECT', '').strip())
short_sha = os.environ.get('SHORT_SHA', '').strip()
repo = os.environ.get('REPO', '').strip()
actor = os.environ.get('ACTOR', '').strip()
run_url = os.environ.get('RUN_URL', '').strip()
head_sha = os.environ.get('HEAD_SHA', '').strip()
channel = os.environ.get('CHANNEL', '').strip()

if is_release and version:
    heading_core = f"{environment} release {status_label}"
    text = f"{emoji} {heading_core} – {version}"
    decorated_heading = f"{emoji} *{heading_core} – {version}*"
else:
    heading_core = f"{environment} CI {status_label}"
    text = f"{emoji} {heading_core}"
    decorated_heading = f"{emoji} *{heading_core}*"

commit_url = f"https://github.com/{repo}/commit/{head_sha}" if repo and head_sha else ''

lines = []
if (is_release and version) or (has_version and version):
    lines.append(f"• *Version*: {version}")

commit_suffix = f" – \"{subject}\"" if subject else ''
if short_sha:
    if commit_url:
        lines.append(f"• *Commit*: <{commit_url}|{short_sha}>{commit_suffix}")
    else:
        lines.append(f"• *Commit*: {short_sha}{commit_suffix}")
elif subject:
    lines.append(f"• *Commit*: \"{subject}\"")
if actor:
    lines.append(f"• *Actor*: @{actor}")
if repo:
    lines.append(f"• *Repo*: {repo}")

payload = {
    'channel': channel,
    'text': text,
    'blocks': [
        {
            'type': 'section',
            'text': {
                'type': 'mrkdwn',
                'text': decorated_heading + ('\n' + '\n'.join(lines) if lines else '')
            }
        }
    ]
}

if run_url:
    payload['blocks'].append({
        'type': 'context',
        'elements': [
            {
                'type': 'mrkdwn',
                'text': f"<{run_url}|View run details>"
            }
        ]
    })

with open('payload.json', 'w', encoding='utf-8') as fh:
    json.dump(payload, fh)
PY

      - name: Send Slack message
        id: slack
        if: steps.validate.outputs.skip != 'true' && steps.env-data.outputs.skip != 'true'
        continue-on-error: true
        uses: slackapi/slack-github-action@v2
        with:
          token: ${{ secrets.SLACK_BOT_TOKEN }}
          method: chat.postMessage
          payload-file-path: payload.json

      - name: Log Slack post result
        if: always() && steps.validate.outputs.skip != 'true' && steps.env-data.outputs.skip != 'true'
        run: |
          if [ "${{ steps.slack.outcome }}" = "failure" ]; then
            echo "::warning::Slack notification failed. Check prior step for details."
          else
            echo "Slack notification step outcome: ${{ steps.slack.outcome }}"
          fi
  noop:
    if: github.event_name == 'push'
    runs-on: ubuntu-latest
    permissions: {}
    steps:
      - name: Skip reusable workflow on push
        run: echo 'Reusable workflow - no action for push trigger.'
